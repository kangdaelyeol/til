# 원시 값과 객체의 비교

- JS 환경에서 메모리에 저장되는 값의 타입을 크게 **원시 타입(primitive type)** 과 **참조 타입(object / reference type)** 으로 구분할 수 있다.

## 원시 타입 - primitive type

- 원시 타입은 변하지 않는 값, 즉 불변성(immutability) 을 가지는 값이다.

- 즉 한 번 원시타입이 할당된 메모리 공간의 값은 변하지 않는다. 이를 통해 값의 **명확성(clarity)** 과 **신뢰성(reliability)** 이 보장된다.

- 원시 타입을 가지는 변수 값을 다른 변수에 할당 하면 값은 **복사** 되어 전달된다. 이를 **값에 의한 전달(pass by value)** 라고 한다.

```javascript
// pass by value - 값에 의한 전달
let a = 10;

/* 변수의 값을 20으로 변경하는 경우
 - 다른 메모리 공간에 20값을 할당한다.
 - a 식별자는 20 값이 할당된 메모리 공간의 주소값을 가리킨다.
 - 따라서 엄밀히 말해 값의 변경은 '재할당'이 아닌 '교체'의 개념으로 이루어진다고 볼 수 있다. */
a = 20;

/* 변수 값을 다른 변수에 할당하는 경우
 
 *** 변수에 값을 할당하는 과정에 메모리 상의 동작은 브라우저 spec마다 차이가 발생할 수 있어 정확한 과정은 알 수 없다. 따라서 크게 두 경우의 수를 가정해 동작방식 파악에 근접해볼 수 있다. ***

1. 값의 복사 이후 식별자에 메모리 주소가 바인딩 되는 경우
 - a 식별자가 가리키는 메모리 주소에 위치하는 값이 다른 메모리 공간으로 복사된다.
 - b 식별자는 복사된 값이 있는 메모리 주소를 가리킨다.
 *** 이 경우 표현식에서 변수는 메모리 값을 전달한다고 볼 수 있다. ***

2. 메모리 주소를 전달한 후(식별자에 메모리 주소가 바인딩 된 후) 재할당이 발생하는 경우
 - b 식별자는 a 식별자가 가리키는 메모리 주소 값을 참조해 가리킨다.
 - 이후 값이 복사되서 재할당이 발생하고, b 식별자는 재할당된 메모리 주소에 바인딩 된다.
 *** 이 경우 표현식은 메모리 값이 아닌 메모리 주소값을 전달한다고 볼 수 있다. *** */

let b = a;

// String type value
const str = 'string'; // string type 값도 원시 타입의 값이다.
str[0] = 'a'; // 이 경우 str 변수 값은 변경되지 않는다. 불변성을 가지기 때문 (Read Only).
```

- 만약 재할당 이외에 원시값을 변경할 수 있는 방법이 있다면 **예키지 않게 변수 값이 변경될 수 있다** 는 의미를 내포하게 된다. 즉 **상태 변경** 을 추적하기 어렵게 한다.

## 참조 타입 - reference / object type

- 참조 타입의 값은 변경 가능(mutable)한 값이다.

- JS 환경에서 **객체** 를 선언함으로 써 참조 타입의 값을 할당할 수 있다

- JS 환경에서 참조 타입 값은 **객체 값이 있는 메모리의 주소값** 을 의미한다. 즉 참조 타입 값을 선언하면 원시 값과 다르게 **두 개의 유효한 메모리 공간(객체 프로퍼티 값을 저장하는 공간, 객체 프로퍼티 값이 있는 메모리의 주소값을 저장하는 메모리 공간)** 이 할당 되는 것이다.

  - 물론 프로퍼티 변수가 원시 타입인 경우, 해당 객체 공간 내부에서 프로퍼티 값의 변경은, **교체(재할당)** 로써 이루어질 것이다.

- 참조 타입(객체) 값을 다른 변수에 할당하는 경우, 두 식별자는 결과적으로 같은 공간을 가리키게 된다. 이러한 메커니즘을 **참조에 의한 전달(pass by reference)** 이라고 한다.

```javascript
// pass by reference - 참조에 의한 전달

const obj = {
	name: 'rkdeofuf',
};

/* 참조 타입 값을 다른 변수에 할당하는 경우

 - obj 변수가 가리키는 메모리공간은 객체 프로퍼티 데이터를 저장하는 메모리 공간의 주소값이 저장되어 있다.
 - obj2 변수에는 obj 변수가 참조하는 주소값이 복사되어 전달된다. 즉 두 변수는 같은 객체 프로퍼티 메모리 공간을 가리키게 된다. */

const obj2 = obj;
```

## 객체

- JS 환경에서 객체는 **프로퍼티 키를 인덱스로 사용하는 Hash Table** 이라고 생각할 수 있다.

- 다른 OOP 기반 언어(C++, Java)와 비교하자면, JS 환경의 객체는 **동적으로 프로퍼티를 추가 또는 삭제** 할 수 있다.

  - 동적 프로퍼티를 제어하는 특징은 사용하기에 편리한 기능일 수 있지만, 객체 지향적 관점에 보았을 때 클래스와의 연관성이 떨어져 객체지향 목적에 어긋난 개발론일 수 있다.

  - 또한 성능적 측면에서도 동적인 프로퍼티 제어는 **프로퍼티 접근에 비용이 더 많이 드는 비효울적인 방식** 이라고 한다.

- V8 JS엔진에서 프로퍼티 접근을 위해 **동적 탐색(dynamic lookup)** 방식 대신 **히든 클래스(hidden class)** 라는 방식을 사용해 C++ 객체 프로퍼티에 접근하는 정도의 성능을 보인다고 한다.

## pass by sharing

- 사살상 JS 환경에서 원시, 참조값을 전달하는 방식에 있어 본질적으로 메모리 공간에 있는 값을 전달한다는 방식만 있기 때문에 **값에 의한 전달(pass by value)** 방식만 있다고 볼 수 있다.

- `pass by value / pass by reference` 두 용어는 다른 언어에서 값 전달 메커니즘에 관한 개념을 설명하는 언어이며, 엄격하게 보았을 때 JS 환경에서는 **pointer 개념이 없어** 구현되지 않는 개념이지만, 개념적으로 유사하게 설명하기 위해 쓰인다.

- 표준 용어는 아니지만 **공유에 의한 전달(pass by sharing)** 이라는 용어로 동작 방식을 설명한다고도 한다.
