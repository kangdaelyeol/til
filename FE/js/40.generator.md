# 제너레이터

- ES6 에서 도입된 제너레이터(generator)를 통해 **함수 진행을 제어** 할 수 있다.

- 함수 진행을 제어한다는 것은, 함수의 호출자를 제어할 수 있다는 것이고, 호출자를 다르게 함으로써 각 호출자 함수와 호출되는 함수의 상태를 공유할 수 있다.

```js
// function 키워드에 *(asterisk) 문자를 추가해 generator 함수를 선언한다.

// generator 함수는 iterable 이면서 iterator인 generator 객체를 반환한다.

// 따라서 new 키워드를 사용해 생성자 함수로써 호출이 불가능하며, arrow function 선언이 불가능하다.

function* countNumber() {
	let count = 0;

	// generator 객체의 메서드 호출을 통해 yield 키워드를 마주치기 전 까지 함수의 흐름이 진행된다.

	// yield 키워드를 만나게되면 함수는 종료하고, yield 키워드의 피연산자 값(오른쪽 값)을 반환한다.

	// 이후 객체의 메서드를 다시 호출할 때 입력한 인수는 yield 키워드에 입력된다.
  try {
    // generator 객체의 throw 메서드를 통해 에러를 입력할 수 있고, 이는 try-catch문을 통해 제어할 수 있다.
    while (count < 10000) count += yield count;
  } catch(console.log)

	return count;
}

// 제너레이터 함수는 제너레이터 객체를 반환한다.
const countGenerator = countNumber();

while (true) {
	const input = Math.floor(Math.random() * 100);

	// 제너레이터 객체는 iterable이면서 iterator이기 때문에 [Symbol.iterator] 프로퍼티 메서드가 존재하며 next 메서드를 호출할 수 있다.

	// next 메서드를 호출하며 기존에 중단되었던 함수의 흐름을 진행할 수 있다.

	//  입력하는 인수는 yield 키워드에 입력된다.
	let result = countGenerator.next(input);

	// next 메서드는 iterator 프로토콜에 따라 iterator result object를 반환한다.

	// 리절트 객체는 value와 done 프로퍼티를 가지고 있다.
	console.log(result.value);

	// 제너레이터 객체는 itrator 프로토콜을 만족하는 next 메서드 외에 return, throw 메서드를 추가적으로 포함한다.


  // return 메서드는 제너레이터 함수의 진행을 무시하고 인수의 값을 value 프로퍼티로 갖고, 'done: true' 값을 가지는 iterator result object를 반환한다.
	if (res.value > 0 && res.value % 100 === 0)
		res = countGenerator.return(10000);

  // throw 메서드는 입력되는 인수를 메시지로 갖는 에러를 던진다(throw) 에러는 제너레이터 함수의 try-catch 문을 통해 제어된다.
  // throw 메서드도 iterator result object를 반환하며, 'value: undefined', 'done: true' 값을 가진다.
	if (res.value === 9999) res = countGenerator.throw('9999');

	if (result.done === true) break;
}
```

- 현재 상황에서는 제너레이터 객체를 하나의 코드블록 환경(while문 블록)에서 여러 번 호출하여 같은 호출자 위에서 제너레이터 함수 흐름이 진행되었다.

- 함수 흐름을 여러 번 나누어 진행할 수 있는 메커니즘을 기반으로 여러 호출자에게 **함수 실행 제어권을 양도** 할 수 있고, 상태를 공유할 수 있다.

## iterable vs generator

- 제너레이터 객체는 iterator 이면서 동시에 iterable 이다. 이는 for문을 통한 순회(loop)가 가능하며, iterable을 직접 구현하는 대신 generator를 활용하여 간단히 이터러블을 생성할 수 있다.

```js
const infiniteFib = (function () {
	let [pre, cur] = [0, 1];

	return {
		[Symbol.iterator]() {
			// 객체 스스로가 next 메서드를 가지고 있으므로 iterator 프로토콜을 만족한다.
			return this;
		},
		next() {
			[pre, cur] = [cur, pre + cur];

			return {
				// 무한 피보나치 값을 반환하기 때문에 done 프로퍼티를 포함하지 않는다.
				value: pre,
			};
		},
	};
})();

for (const num of infiniteFib) {
	console.log(num);
	if (num > 10000) break;
}

const fibGenerator = (function* () {
	let [pre, cur] = [0, 1];

	while (true) {
		yield cur;
		[pre, cur] = [cur, pre + cur];
	}
})();

// generator 객체는 iterable 프로토콜을 만족하기 때문에 for .. of 문을 통한 순회가 가능하다.
for (const num of fibGenerator) {
	console.log(num);
	if (num > 10000) break;
}
```
