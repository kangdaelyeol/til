# 비동기 프로그래밍

- JS 엔진은 싱글 스레드(single thread)를 지원하며, 하나의 실행 컨텍스트 스택을 가진다.

- 현재 실행중인 실행 컨텍스트의 작업 시간이 오래 걸릴 경우 나머지 테스크는 **블로킹(blocking)** 상태가 된다

- 다음 실행될 작업이 현재 실행되고 있는 작업이 끝날 때 까지 기다렸다 순차적으로 실행하는 방식을 **동기(synchronous) 처리** 라고 한다.

  - 동기 처리 방식은 **실행 순서가 보장** 되는 장점이 있지만, 작업이 **블로킹** 되는 단점이 있다.

- 반대로 현재 실행중인 작업이 종료되지 않았음에도 다른 작업이 실행되는 방식을 **비동기(asynchronous) 처리** 라고 한다.

  - JS 엔진 자체는 싱글 스레드를 지원하기 때문에 비동기 처리가 불가능 하지만 **멀티 쓰레드를 지원하는 브라우저에 처리(process) 를 위임** 함으로써 비동기 처리가 가능하다.

  - 타이머 함수, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작한다.

## 이벤트 루프 - event loop

- 이벤트 루프는 브라우저의 논리적 메모리 공간들을 루프(loop) 하면서 각각의 기능을 순차적으로 수행한다

- 브라우저는 **이벤트 루프(event loop)** 를 기반으로 동작하며, 이를 통해 한 번에 여러 동작, 처리를 함으로써 동시성(concurrency)을 보장한다.

- 이벤트 루프 기준으로, 실행 컨텍스트에서 실행중인 실행 컨텍스트(running execution context)를 제외한 나머지 하위 실행 컨텍스트, 테스크 큐의 쌓인 작업 단위를 **테스크(task)** 로 구분한다.

- 비동기 처리가 완료된 event handler, settimeout callback function등은 JS 엔진에 의해 호출되기 전 **테스크 큐(task queue)** 에 테스크로써 FIFO 형태로 쌓인다.

  - **custom event, click method** 등 DOM API를 통해 **이벤트를 직접 발생** 시키면을 사용하면 테스크 큐를 거치지 않고 **동기적으로 처리된다.**

- 이벤트 루프는 실행 컨텍스트 스택인 **콜 스택(call stack)** 이 비어있고, 테스크큐에 테스크가 존재하면 순차적으로(FIFO) 테스크 큐의 테스크들을 콜 스텍으로 옮겨 실행될 수 있게 한다.

  - 타이머 함수의 경우 타이머 작업이 완료된 후 등록된 콜백 함수가 브라우저 멀티 쓰레드에 의해 테스크 큐로 푸시(push) 된다.

  - 즉 브라우저가 테스크 큐에 push 하는 작업과 이벤트 루프가 콜 스텍에 push 하는 작업은 **병행 처리** 된다.
