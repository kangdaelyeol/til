# 프로토타입

## 객체지향 프로그래밍

- JS는 multi-paradigm programming 언어이며, prototype 기반의 객체지향 언어라고 할 수 있다.

- 실제 사물에 대해 필요한 특징만 추출해 표현하는 추상화(abstraction) 과정을 거쳐 하나의 논리적 단위로써 객체(Object)를 생성한다.

- 객체는 데이터 상태를 표현하는 **프로퍼티(property)** 와 상태를 조작하는 동작으로써의 **메서드(method)** 를 묶은 복합 데이터로 설명될 수 있다.

`ES6에 추가된 class 문법 또한 프로토타입 기반 생성자 함수를 기반으로 객체를 생성하기 때문에 문법적 설탕(syntactic sugar) 이라고 볼 수 있다. 하지만 정확하게 생성자 함수와 클래스가 동일한 메커니즘으로 객체를 생성하지는 않는다고 한다.`

## prototype 내부슬롯

- JS의 모든 객체는 Prototype을 기반으로한 상속을 구현한다.

- 모든 생성자 함수는 자신의 prototype 프로퍼티를 가지고 있으며, 인스턴스는 생성자 함수의 프로퍼티인 prototype 객체를 `[[Prototype]]` 내부 슬롯에 할당한다

- prototype 기반 상속을 활용해서 **메서드 중복 정의 문제** 를 방지할 수 있다.

```javascript
// 생성자 함수를 통해 생성된 인스턴스는 각각의 독립된 프로퍼티와 동시에 메서드를 가지게 된다.
// 또한 함수 선언문 런타임 이전에 평가되어 함수 객체를 생성함과 동시에 prototype 객체를 생성하고. 이는 생성자 함수의 prototype 프로퍼티에 바인딩 된다. 그리고 생성자 함수는 prototype객체의 constructor프로퍼티에 바인딩 된다.

// 프로퍼티는 각 인스턴스의 개체로써 구분 짓기 위해 개별적인 값으로써 합리성이 있지만, 메서드는 같은 동작이기 때문에 각 인스턴스가 같은 메서드를 가지게 되어 자원 소모에 있어 비효율적이다.

function Circle(radius) {
  this.radius = radius;

  this.getDiameter() {
    return this.radius * 2;
  }

  this.getPerimeter() {
    return Math.PI * this.radius * 2;
  }
}

// 이러한 문제를 프로토타입 기반 상속을 통해 해결할 수 있다.

function ImprovedCircle(radius){
  this.radius = radius;
}

// prototype 프로퍼티를 통한 메서드 정의
ImprovedCircle.prototype.getDiameter = function () {
  return this.radius * 2;
}

ImprovedCircle.prototype.getPerimeter = function () {
  return this.radius * 2 * Math.PI;
}

const circle1 = new ImprovedCircle(1)
const circle2 = new ImprovedCircle(2)

// 각 인스턴스는 같은 메서드를 가리킨다.
console.log(circle1.getDiameter === circle2.getDiameter) // true

// 인스턴스는 생성자 함수의 prototype프로퍼티를 내부슬롯으로써 상속 받는다.
console.log(Object.getPrototypeOf(circle1) === ImprovedCircle.prototype); // true


// 인스턴스의 프로퍼티 참조는 프로토타입 객체의 탐색으로 이어진다.
// 프로토타입 객체는 constructor 프로퍼티를 가지며 생성자 함수 객체를 바인딩한다.
console.log(ImprovedCircle === circle1.constructor); // true

// 생성자 함수 또한 prototype이 있으며, constructor는 Function built-in 객체를 가리킨다.
console.log(Function.prototype === Object.getPrototypeOf(ImprovedCircle)); // true

console.log(ImprovedCircle.constructor === Function); // true

// 생성자 함수로써 호출할 수 없는 non-constructor는 prototype이 생성되지 않는다.

const Person = (name) => {this.name = name} // non-constructor

// 모든 프로토타입 객체의 프로토타입 내부슬롯은 Object.prototype이다.

console.log(Object.getPrototypeOf(Function.prototype) === Object.prototype); // true

console.log(
	Object.getPrototypeOf(Object.getPrototypeOf(ImprovedCircle)) ===
		Object.prototype
); // true
```

## OrdinaryObjectCreate

- JS 환경에서 객체를 생성할 때 내부적 메커니즘인 `[[OrdinaryObjectCreate]]` 메서드가 실행된다.

- 객체를 생성하면 객체에 대한 프로토타입 객체를 바인딩하는데, OrdinaryObjectCreate 과정에서 바인딩될 프로토타입 객체를 결정한다.

```javascript
function ImprovedCircle(radius) {
	this.radius = radius;
}

// prototype 프로퍼티를 통한 메서드 정의

ImprovedCircle.prototype.getPerimeter = function () {
	return this.radius * 2 * Math.PI;
};

// OrdinaryObjectCreate 메커니즘에 의해 ImprovedCircle.prototype 객체가 프로토타입으로 결정되어 바인딩된다.
const circle1 = new ImprovedCircle(1);

// OrdinaryObjectCreate 메커니즘에 의해 Object.prototype 객체가 프로토타입으로 결정되어 바인딩된다.
const obj1 = {};
const obj2 = new Object();
```
