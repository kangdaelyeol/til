# 모듈

- 모듈을 생성함으로써 코드를 분리할 수 있다.

- 각각의 모듈은 자신만의 파일 스코프(모듈 스코프)를 가질 수 있어야 한다.

  - 기존 JS 환경에서 스크립트를 여러 파일로 분리해도 결국엔 하나의 전역(window)을 공유하기 때문에 변수 이름에 대한 충돌 가능성이 있다.

  - 모듈화를 통해 생성된 JS 모듈의 모든 자산은 **캡슐화(encapsulated)** 되어 자신만의 파일 스코프를 가질 수 있기 때문에, 다른 모듈에서 접근할 수 없다. 따라서 변수 충돌을 줄인다.

- 모듈의 자산중 공개할 필요가 있는 자산을 공개(export) 하고, 다른 모듈로부터 필요한 자산만을 불러들여(import) 사용한다.

  - 코드의 단위를 명확히 분리하여 모듈화 함으로써 유지보수성, 재사용성을 보장한다.

  - 반복되는 코드를 모듈화 함으로써 재사용성을 높일 수 있고, 기능 단위가 명확한 코드를 모듈화 함으로써 추적성(traceability), 직관성(intuitiveness)을 보장할 수 있다.

## JS 모듈

- 기본적인 JS 환경은 하나의 전역을 공유하기 때문에 여러 js파일을 로드해도 하나의 JS 파일에 있는 것처럼 동작한다.

- JS를 브라우저 환경에 국한하지 않고 범용적으로 사용하려는 상황이 진행되면서 CommonJS, AMD(Asynchronous Module Definition)가 제안되었다.

  - AMD는 과거에 require.js 라이브러리에 구현되어 클라이언트 사이드에서 비동기로 모듈을 로드하기 위해 사용되었다.

  - Node.js 환경은 기본적으로 **require, module.exports** 키워드를 사용하는 CommonJS 모듈 로더 라이브러리를 사용한다. 정확히 100% 일치하는 CommonJS 사양은 아니지만 대부분 일치한다고 한다. CommonJS는 공식 ECMAScript 표준은 아니지만, **사실상의 표준(de facto standard)** 으로 사용된다고 한다.

  - 클라이언트 사이드 JS에서는 **import, export** 키워드를 사용하는 ES6 모듈(ESM)을 사용한다.

    - script 태그에 **type="module"** 속성을 추가하면 모듈로써 동작한다. 모듈임을 명확히 하기 위해 **mjs** 확장자 사용이 권장된다.

    - Node.js 환경에서도 **type="module"** 선언을 통해 ESM 모듈 시스템을 사용할 수 있다.
