# Event

- JS는 event-driven programming을 지원한다.

  - 브라우저에서 이벤트가 발생하여 호출되는 함수를 **이벤트 핸들러(event handler)** 라고 한다.

  - 이벤트 핸들러를 정의해 브라우저에 호출을 위임한다.

  - 브라우저에서 특정 이벤트가 발생할 때 event handler를 호출하도록 함수를 위임하는 방식을 **event-driven programming** 이라고 한다.

## 이벤트 핸들러 등록

- DOM 요소에 이벤트 핸들러를 세 가지 방법으로 등록할 수 있다.

### 이벤트 핸들러 어트리뷰트 방식

- HTML markup 어트리뷰트에 직접 이벤트 핸들러를 정의한다.

- 이벤트 이름과 **'on'** 접두사를 붙여 등록할 수 있고, 이벤트 객체는 암묵적으로 `event` 로써 명명되어 전달된다.

  - 즉 이벤트 핸들러 어트리뷰트 방식은, 함수 참조를 입력하는 것이 아닌, `이벤트 핸들러의 몸체를 정의` 하는 방식이다.

```html
<div
	class="box"
	style="background-color: gray; width: 100px; height: 100px"
	onclick="console.log(event); console.log('attribute handler')"
></div>
```

### 이벤트 핸들러 프로퍼티 방식

- JS DOM 프로퍼티에 이벤트 핸들러를 등록하는 방식이다.

- 같은 이벤트에 대하여 어트리뷰트, 프로퍼티 이벤트 핸들러를 등록한 경우, 이벤트 핸들러 어트리뷰트는 실행되지 않고 이벤트 핸들러 프로퍼티가 실행된다.

  - 이벤트 핸들러 어트리뷰트는 HTML 파싱 과정에서 이벤트 핸들러 프로퍼티로 해석되어 DOM 객체에 등록되므로, 이벤트 핸들러 프로퍼티를 정의해 DOM 객체에 등록하면 **중복 정의(override)** 되어 덮어쓰인다.

- 이벤트 핸들러 프로퍼티 방식은 `함수 참조` 를 등록하며, 암묵적으로 이벤트 객체를 parameter로 넘겨 받는다.

### addEventListener 메서드 방식

- EventTarget 인터페이스 객체에서 제공하는 addEventListener 메서드를 통해 구독형(subscribe) 이벤트 처리를 할 수 있다.

- [MDN 문서](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)에 따르면 addEventListener 메서드를 통한 이벤트 핸들러 등록이 권장된다.

  - 여러 핸들러를 등록할 수 있고, 더욱 세밀한(finer-grained) 제어가 가능하고, HTML, SVG 요소는 포함한 어떠한 event target에도 사용이 가능하기 때문이다.

  - 함수 참조가 동일하지 않는 메서드는 겹치지 않으므로, 여러 이벤트 핸들러를 등록할 수 있고, 이벤트 발생시 등록한 순서대로 핸들러가 호출된다.

  - 이벤트 핸들러를 저장하기 위해선 이벤트 핸들러 함수를 익명함수로써 등록하지 않고, 반드시 변수와 같은 자료 구조에 저장하고 있어야 한다.

## 이벤트 객체

- 이벤트 객체는 이벤트 타입에 따라 종류가 다양하며 상속 구조를 갖는다.

- 모든 이벤트는 기본적으로 [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event) 인터페이스 객체를 상속 받고, Event 객체는 Object 객체를 상속 받는다.

- 각 Event 객체 마다 고유의 프로퍼티를 제공한다.

```js
const movedPos = { x: 0, y: 0 };
const prevPos = { x: 0, y: 0 };

const move = (e) => {
	movedPos.x += e.clientX - prevPos.x;
	movedPos.y += e.clientY - prevPos.y;
	prevPos.x = e.clientX;
	prevPos.y = e.clientY;
	boxEl.style.transform = `translate3d(${movedPos.x}px, ${movedPos.y}px, 0)`;
};

boxEl.addEventListener('mousedown', (e) => {
	// 마우스와 관련된 이벤트는 MouseEvent인터페이스 객체의 인스턴스다.
	// Event <- UIEvent <- MouseEvent 상속 구조를 갖는다.
	console.log(e.constructor === MouseEvent);
	console.log(Object.getPrototypeOf(MouseEvent) === UIEvent);
	console.log(Object.getPrototypeOf(UIEvent) === Event);
	// MouseEvent 객체는 client, offset, page 프로퍼티를 제공해 이벤트가 발생한 위치를 알 수 있다.
	// clientX / Y - Viewport 기준 상대적 위치
	// offsetX / Y - 이벤트가 발생한 요소를 기준 상대적 위치
	// pageX / Y - 전체 문서(document) 기준 상대적 위치
	console.log(e.clientX, e.offsetX, e.pageX);
	prevPos.x = e.clientX;
	prevPos.y = e.clientY;
	document.addEventListener('mousemove', move);
});

document.addEventListener('mouseup', (e) => {
	document.removeEventListener('mousemove', move);
});
```

### KeyboardEvent

- CJK language와 같은 **조합형 언어** 는 단어를 입력할 때 [IME](https://developer.mozilla.org/en-US/docs/Glossary/Input_method_editor)와 연동된 상태로 이벤트가 발생한다.

- IME를 통해 [CompositionEvent](https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent) 타입인 compositionstart, compositionupdate, compositionend 이벤트가 발생하는데, 이와 관련해 keydown, keyup 이벤트가 두 번 호출되는 브라우저 버그가 있다.

  - [KeyboardEvent.isComposing](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/isComposing) 프로퍼티를 통해 조합 상태를 확인 할 수 있다.

- 한글 입력 도중(event.isComposing === true) Enter, Tab, ArrowUp 등 커서를 이동하는 입력을 하게 되면 해당 키에 대한 key 이벤트가 추가적으로 호출되어 총 두번 호출되는 버그가 있다.

  - 이 버그는 브라우저 문제로 chrome 브라우저에서 발견되었고, safari 브라우저에서는 버그가 발생하지 않는다.
